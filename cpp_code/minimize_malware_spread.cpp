/*
924. Minimize Malware Spread

In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

Some nodes initial are initially infected by malware.
Whenever two nodes are directly connected and at least one of those two nodes is infected by malware,
both nodes will be infected by malware.
This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network,
after the spread of malware stops.

We will remove one node from the initial list.
Return the node that if removed, would minimize M(initial).
If multiple nodes could be removed to minimize M(initial),
return such a node with the smallest index.

Note that if a node was removed from the initial list of infected nodes,
it may still be infected later as a result of the malware spread.

Example 1:
Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0

Example 2:
Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0

Example 3:
Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1

Note:
1 < graph.length = graph[0].length <= 300
0 <= graph[i][j] == graph[j][i] <= 1
graph[i][i] = 1
1 <= initial.length < graph.length
0 <= initial[i] < graph.length
*/
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>
#include <cmath>
#include <queue>
#include <stack>
#include <stdio.h>
#include <map>
#include <numeric>
using namespace std;
/*
Union found all nodes.
Count the union size of each union set.
Count the malware number of each union set.

Return the biggest union's malware if there is one and only one malware.
If no such union that has and has only one malware,
return the malware with minimum index.
*/
class Solution {
private:
    int find(int num, vector<int>& parent) {
        if (parent[num] != num) {
            parent[num] = find(parent[num], parent);
        }
        return parent[num];
    }

    void unin(int num1, int num2, vector<int>& parent) {
        int p1 = find(num1, parent);
        int p2 = find(num2, parent);
        if (p1 != p2) {
            parent[p1] = p2;
        }
    }
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> parent(n, 0);
        iota(parent.begin(), parent.end(), 0);
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) if (graph[i][j] == 1) {
                unin(i, j, parent);
            }
        }

        vector<int> area(n, 0);
        vector<int> malware(n, 0);
        for (int i = 0; i < n; ++i) {
            area[find(i, parent)] += 1;
        }
        for (int i : initial) {
            malware[find(i, parent)] += 1; // malware means how many malware are in the same area
        }

        vector<int> result({1, 0});
        /*
        * for any area with more than one malware it will generate {0, area}, which is bigger than any {negative num, node}
        * thus we will pick smallest node from initial if there is no area affected by only one node
        * if there is an area affected by one node than we compare using {-area, node}
        * so we will always pick the node with biggest area which is consider as smallest
        */
        for (int i : initial) {
            result = min(result, {(malware[find(i, parent)] == 1) * (0 - area[find(i, parent)]), i});
        }
        return result[1];
    }
};

class Solution1 { // too slow faster than 5.11%
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int nodes = graph.size();
        unordered_map<int, unordered_set<int>> infectedBy;
        queue<pair<int, int>> bfs;
        int minInfection = INT_MAX;
        for (int i : initial) {
            minInfection = min(minInfection, i); // it is possible that every node will be infected by multiple sources, in that case we will have to return the smallest index
            infectedBy[i].insert(i);
            bfs.push({i, i});
        }

        while (!bfs.empty()) {
            int curNode = bfs.front().first;
            int source = bfs.front().second;
            bfs.pop();

            for (int nextNode = 0; nextNode < graph[curNode].size(); nextNode++) {
                if (nextNode != curNode and graph[curNode][nextNode] == 1 and infectedBy[nextNode].find(source) == infectedBy[nextNode].end()) {
                    infectedBy[nextNode].insert(source);
                    bfs.push({nextNode, source});
                }
            }
        }

        unordered_map<int, int> onlySource;
        for (auto& infection : infectedBy) {
            int node = infection.first;
            unordered_set<int> sources = infection.second;
            if (sources.size() == 1) {
                for (int source : sources) {
                    onlySource[source] += 1;
                }
            }
        }

        int count = INT_MIN;
        int result = -1;
        for (auto& os : onlySource) {
            if (count < os.second) {
                count = os.second;
                result = os.first;
            }
            else if (count == os.second) {
                result = min(result, os.first);
            }
        }
        return count == INT_MIN ? minInfection : result;
    }
};
